## Gentle Introduction to Object Oriented Programming - Part 3

### Polymorphism

Polymorphism ဆိုတာ Greek ဘာသာစကား Poly (မ်ားစြာေသာ) Morph( ပံုသ႑ာန္ေၿပာင္းၿခင္း) ဆိုတာကေန ဆင္းသက္လာတာပါ။ Polymorphism is the ability to present the same interface for differing underlying forms (data types). တူညီတဲ့ interface (public method or method) ေပၚမွာ contextual object သုိ.မဟုတ္ data type အေပၚမူတည္ၿပီး ေၿပာင္းလဲႏုိင္မွု.ကိုေၿပာတာပါ။ ၿမန္မာလို ရိုးရိုးရွင္းရွင္းေၿပာရမယ္ဆုိရင္ Human လူဆုိရင္ work ဆိုတဲ့ method ရိွပါတယ္။ Teacher, Doctor ေတြဟာလဲ kind of Human ၿဖစ္တဲ့အတြက္ work ဆိုတဲ့ method ရိွပါတယ္။ ဒါေပမဲ့ Teacher က work ဆုိရင္ေတာ့ စာသင္မွာၿဖစ္ၿပီးေတာ့ Doctor ရဲ. work ဆုိရင္ေတာ့ ေဆးကုမွာပါ။ work ဆုိတဲ့ တူညီတဲ့ interface ေပၚမွာ method call (message passing) လုပ္တာပါပဲ။ ဒါေပမဲ့ အေခၚခံရတဲ့ object အလိုက္မူတည္ၿပီး work ရဲ. implementation ကြာမွာပါ။ ေအာက္က Java Code ကိုၾကည့္ပါ။

    class Human { public void work() {} }
    
    class Teacher extends Human { public void work() { System.out.println("I teach tutorial"); } }
    
    class Doctor extends Human { public void work() { System.out.println("I give medical treatment"); } } class Test { public static void main(String args[]) { Human h = new Teacher(); h.work();
    
    h = new Doctor(); h.work(); } }

### Dynamic Polymorphism

အေပၚက code မွာ Teacher ေရာ Doctor ၂ခုစလံုးက Human ကုိ extends လုပ္ၿပီးေတာ့ work method ကုိ override လုပ္ထားပါတယ္။ ေအာက္က Test class ရဲ. main မွာ ပထမဆံုး Teacher ကိုေဆာက္ၿပီး Human အမ်ိဳးအစားၿဖစ္တဲ့ h ထဲကိုထဲ့ပါတယ္။ h သည္ base class reference ၿဖစ္တာေၾကာင့္ child object (Teacher) ကိုထဲ့ခြင့္ရပါတယ္။ ဒါက sub typing သေဘာအရခြင့္ေပးတာပါ။ Parent reference type ထဲကို child object ေတြထဲ့ခြင့္ရိွပါတယ္။ ၿပီးေတာ့ h.work() လို. method ကုိေခၚပါတယ္။ ဒါေပမဲ့ h.work() သည္ Teacher object ရဲ. work ကုိလွမ္းေခၚမွာၿဖစ္ပါတယ္။ ဘာလုိ.လဲဆုိေတာ့ java method ေတြက static မေၾကၿငာထားရင္ auto virtual ၿဖစ္လို.ပါ။ Human ရဲ. work ကိုေခၚမဲ့အစား h ထဲမွာတကယ္ရိွတဲ့ object Teacher ကုိေခၚပါလိမ့္မယ္။ဒါဟာ polymorphism ပါပဲ။ ေနာက္တခါ h ထဲကို Doctor ထဲ့ထားၿပီး h.work လို.ေခၚမယ္ဆုိရင္ေတာ့ doctor class ရဲ. work ကုိေခၚပါလိမ့္မယ္။ ကြ်န္ေတာ္တို. ေခၚတာ h.work ပါပဲ (same method) ပါ။ ဒါေပမဲ့ implementation (execute လုပ္မွာသည္ Teacher ရဲ. work လား Doctor work လား)ကုိေတာ့ h ထဲမွာ ေရာက္ေနတဲ့ object ေပၚမူတည္ၿပီး ဆံုးၿဖတ္မွာပါ။ ဒါေၾကာင့္ Polymorphism သည္ same method with different implementation လုိ.လဲဆုိၾကပါတယ္။ တစ္ခုသတိထားရမွာက static language (Java,C#,C++)မွာ polymorphism သည္ virtual method မွာပဲအလုပ္လုပ္ပါတယ္။ Java မွာေတာဘာမွမေရးရေပမဲ့ C++ မွာ virtual လို.ေရးရၿပီး pointer နဲ.သံုးရပါတယ္။ C# မွာေတာ့ parent class method မွာ virtual လို.ေရးရၿပီး child class method မွာေတာ့ override ဆုိတဲ့ keyword ကိုထဲ့ေပးရပါတယ္။

ဘာေၾကာင့္ polymorphism ကုိသံုးရတာလဲ သူ.ရဲ. ေကာင္းက်ိဳးေတြက ဘာေတြလဲလို.ေမးစရာရိွပါတယ္။ Polymorphism သံုးၿခင္းအားၿဖင့္ hard code ေရးရတာ ဥပမာ object က Teacher ဆို teacher work ကိုေခၚပါဆုိၿပီး လိုက္ေရးစရာမလိုပါဘူး။ ဒါကဘာေကာင္းလဲဆုိေတာ့ ေနာင္တခ်ိန္မွာ တၿခား Engineer လုိ class တခု ထပ္ထည့္မယ္ဆုိရိွၿပီးသား code ေတြ ထိစရာမလိုပဲနဲ. ၿပင္ႏုိင္ပါတယ္။ Extensibility ေကာင္းတယ္ လို.ေၿပာရမွာပါ။ ဒီၿပင့္ေနရာေတြလဲရိွပါေသးတယ္။ ဥပမာ ၿပရရင္ Procedural language နဲ.ယွဥ္ေပးရမွွာပါ။ PHP စေပၚကာစက OOP ကုိ support မလုပ္ေသးပါဘူး ။ အဲ့အခ်ိန္မွာ database ကို connect လုပ္တဲ့ code ေတြကို function ေတြအေနနဲ.ေရးရပါတယ္။ ဥပမာ MySQL ကုိခ်ိတ္မယ္ဆုိရင္ mysql_connect ဆိုတဲ့ function ကိုသံုးရပါတယ္။ Oracle ကုိ connect လုပ္ခ်င္ရင္ေတာ့ oci_connect ဆုိတဲ့ function ကုိသံုးရပါတယ္။ တၿခား sql statment ေတြ execute လုပ္ခ်င္ရင္လဲ သက္ဆုိင္ရာ mysql oracle function ေတြလိုက္သံုးရပါတယ္။ တၿခား datsbase server ေတြဆုိလဲ သူတုိ. နဲ.ဆုိင္တဲ့ method ေတြလိုက္မွတ္ရပါတယ္။ ဒါဟာ programmer တေယာက္အတြက္ မေကာင္းလွပါဘူး။ ေနာက္ပိုင္းမွာ PHP မွာ OOP ရလာၿပီး PDO (PHP Data Object) ဆိုၿပီး Polymorphism,Inheritance သံုးၿပီး database function ေတြကိုေၿပာင္းေရးလိုက္ပါတယ္။ တကယ္ေတာ့ mysql connect နဲ. oracle connect သည္ implementation ပဲကြာတာပါ ဒါကုိ OO thinking အရ connect ဆုိၿပီး ဘံုထုတ္ polymorphism အရ oracle PDO ဆုိရင္ oracle connection code လွမ္းေခၚ MySQL PDO ဆုိရင္ MySQL connection code ကိုလွမ္းေခၚေပးရံုပါပဲ။ ဒါဆုိ database ေတြဟာ implementation ေတြသာ ကြာခ်င္ကြာမယ္ connection ခ်ိတ္တာ sql statement ေတြ run တာကို method ေတြအေနနဲ.ဘံုထုတ္လိုက္ေတာ့ Programmer က MySQL ခ်ိတ္ေနတာလား Oracle ခ်ိတ္ေနတာလား ေၿပာစရာမလိုပဲသံုးလို.ရ႔ပါၿပီ။ Abstraction ပုိင္းအရၾကည့္ရင္ Programmer က အမ်ားၾကီး လုိက္မွတ္စရာမလိုေတာ့ပါဘူး ။ PDO မွာ database server အားလံုးအတြက္ လိုမဲ့ public interface ေတြထားၿပီး database တခုၿခင္းဆီအတြက္ different implemnetation ကုိ extends လုပ္ၿပီးေပးလုိက္ယံုပါပဲ။ တကယ္လုိ. Programmer က MySQL ကေန Oracle ကိုေၿပာင္းမယ္ဆုိရင္ PDO မွာလြယ္ပါတယ္ connection string ေၿပာင္းယံုပါပဲ။ နဂို procedural programming style အရသာဆုိရင္ database code အကုန္ကုိေၿပာင္းရမွာပါ။ ေနာက္တခါ database server အသစ္တခု ထပ္ထြက္တယ္ဆိုပါစုိ.ဒါဆုိရင္လဲ ရွိတဲ့ PDO class ကုိ inherit သံုးၿပီး different implementation ေပးလိုက္ယံုပါပဲ။ ဒါဆုိ polymorphism ရဲ.အသံုး၀င္ပံုကုိသိေလာက္ပါၿပီ။ Java , C# တို.မွာလဲ ဒီလိုသေဘာတရားသံုးၿပီး JDBC , ADO.NET API ေတြကိုေဆာက္ထားတာပါ။ ခုကြ်န္ေတာ္ေၿပာသြားတဲ့ Polymorhpism အမ်ိဳးအစားကုိ dynamic polymorphism လို.ေခၚပါတယ္။ ဘာလို.လဲဆုိေတာ့ ဘယ္ method ရဲ. code (implementation ) run မယ္ဆုိတာကို run time (dynamic ) ေရာက္မွ ဆံုးၿဖတ္လို.ပါပဲ။

### Subtyping vs Duck Typing

Dynamic polymorphism ကိုလုပ္မယ္ဆုိရင္ static language (C++,Java,C#) တုိ.မွာ parent type (super type) reference ထဲကုိ child type(sub type) object ေတြထဲ့ရပါတယ္ ။ ၿပီးေတာ့မွ parent type ရဲ. reference ကေန method ကုိေခၚရပါတယ္။ Static language ေတြမွာ dynamic polymorphism ကိုပံုေဖာ္ခ်င္ရင္ အနည္းဆံုး subtyping ၿဖစ္ေအာင္လုပ္ရပါတယ္။ Inheritance နဲ. interface inheritance(Java မွာေတာ့ interface ကုိ implements လို.သံုးတာပါ) နည္းနဲ. subtyping ကုိလုပ္လုိ.ရပါတယ္။ Dynamic language ေတြမွာေတာ့ type ေတြ သည္ dynanmic (variable တခုရဲ. type သည္ ပံုေသမဟုတ္ run time မွာ ေၿပာင္းလဲႏုိင္သည္) ၿဖစ္တဲ့အတြက္ subyting မလိုပါဘူး။ ဒါကို က်ေတာ့ duck typing လို.ေခၚပါတယ္။ ဥပမာ static language ေတြမွာ object တခုမွာ work ဆုိတာရိွလဲ subtyping (type အရ assignable )ၿဖစ္မွသာေခၚလုိ.ရမွာပါ။ Dynamic language မွာေတာ့ method ရိွတာနဲ.တင္ေခၚလုိ.ရပါၿပီ။ ေခၚတဲ့ object သည္ ဘာ type ၿဖစ္ရမယ္ ဆုိတဲ့ ကန္.သတ္ခ်က္မရိွပါဘူး။ Duck typing လို.ဘာလုိ.ေခၚသလဲဆုိေတာ့ ဘဲလို ေအာ္တယ္ ဘဲလိုသြားရင္ ဘဲ ပဲေပါ့တဲ့။ Object တခုမွာ ကုိေခၚတဲ့ method ရိွရင္ရၿပီ ဘာ type rule မွရိွစရာမလိုဘူးလုိ.ဆိုခ်င္တာပါ။

### Static Polymorphism

Static polymorphism ဆုိေတာကေတာ့ method overloading ကုိေၿပာခ်င္တာပါ။ method ေတြကို နာမည္တူရမယ္ ၊ return type (sub type ဆိုလဲရ) တူရမယ္ ဒါေပမဲ့ protocol မတူပဲ ေရးရင္ ဒါကို method overloading လို.ေခၚပါတယ္။ Method protocol ဆုိတာ ဒီေနရာမွာ method တခုရဲ. parameter အေရအတြက္ ၊ parameter type ၊ parameter order အားလံုးကိုေၿပာတာပါ။ static polymorphism လို.ေခၚရၿခင္းကေတာ့ method overloading မွာ ဘယ္ metod ကုိေခၚမယ္ဆုိတာကို compile time မွာ ဆံုးၿဖတ္လို.ပါ။ Dynamic language ေတြၿဖစ္တဲ့ Ruby, Python, JavaScript နဲ. PHP တုိ.မွာ method overloadig မရိွပါဘူး။

### Parametric Polymorphism

ေနာက္ဆံုးတခုကေတာ့ Parametric polymorphism ပါသူကေတာ့ C++ မွာဆုိ template, Java, C# မွာဆုိရင္ generic လို.ေခၚပါတယ္။ Parametric polymorphism သည္ dynamic language ေတြမွာမရိွပါဘူး။ Static language ေတြမွာပဲရိွတာပါ။ ဥပမာ Stack တို. LinkList တုိ.ဆုိတာ ဘံုသံုးပါ integer ေတြထဲ့မဲ့ stack ရိွႏို္င္သလို string ေတြထဲ့မဲ့ stack လဲရိွႏဳိင္ပါတယ္။ Integer အတြက္ stack တခု string အတြက္ stack တခုေရးမယ္ဆုိရင္ code ေတြေဖာင္းပြကုန္ပါတယ္။ ဒါေၾကာင့္ template, generic code ေတြေရးၿပီး တကယ္သံုးေတာ့မွ data type ကုိ parameter အေနနဲ.ပို.လိုက္တာပါ။ အဲ့ေတာ့ compiler, runtime system ကေနၿပီး ဆုိင္ရာ stack (integer ေပးလုိက္ရင္ integer stack ေပါ့ဗ်ာ) ထုတ္ေပးပါတယ္။ အဲ့ေတာ့ code သည္ reusable ၿဖစ္တယ္။ type safe ၿဖစ္တယ္ေပါ့ဗ်ာ။
