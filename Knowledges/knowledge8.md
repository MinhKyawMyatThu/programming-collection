## Non-blocking IO vs blocking IO
Programmer ေတြတခါတေလ အေရမရ အဖတ္မရ ၿငင္းၾကတဲ့အထဲမွာ ငါ့ language က ၿမန္တယ္ သူ. language က ၿမန္တယ္ဆုိတာ။ဘယ္ဟာကၿမန္တာလဲ CPU ေပၚလုပ္တဲ့ task လား IO လုပ္တဲ့ေကာင္လား။ ဒါမွမဟုတ္ thread operation ေတြမွာ lock ေတြ ေစာင့္စရာမလိုပဲလုပ္ႏုိင္တာမ်ိဳးလား မသဲသာ မသဲကြဲတာ။ တခါၿမင္ဖူးပါတယ္ PHP နဲ. Node.js မွာ PHP ကပိုၿမန္တယ္ဆုိတာ။ ကုိယ္နဲ.လဲ မဆုိင္လုိ. ၀င္ေတာ့မေၿပာမိဘူး။

ခုနက ၿမန္တယ္ဆုိတဲ့ ကိစၥ ကုိဆက္ရရင္ ခု language ေတြမွာ Node.js (သူကေတာ့ language ဆုိတာထက္ runtime environment လို.ေၿပာရင္ပိုမွန္မယ္) မတုိင္ခင္အထိက CPU computing time ကိုပဲ ေၿပာတာ မ်ားၾကတယ္။ ေနာက္ Node.js ေပၚလာေတာ့ response တုိင္းကိုေၿပာလာၾကတယ္။ Node.js ကၿမန္တယ္ဆုိတာ response time ကိုေၿပာတာ။

ဒါဆုိ Response time ဆုိတာဘာလဲဆုိတာေၿပာဖုိ.လိုလာၿပီ။ Response time ကုိေၿပာဖုိ.ဆုိရင္ execution time ဆုိတာသိဖုိ.လိုလာၿပီ။ Execution time ဆုိတာ task တခု (ဆုိၾကပါစုိ. program function တခုခုေပါ့) ကို CPU အေပၚမွာ တင္ၿပီး run ဖုိ.ၾကာတဲ့အခ်ိန္ကိုဆုိလုိတာ။ ဆုိခ်င္တာက a+b အဲ့လို arithmetic ေတြ if လို jump ေတြသည္ CPU ေပၚမွာလုပ္ရတာ ဒီလိုေကာင္ေတြဖုိ.ဆုိ execution time လို.ဆုိတယ္။

Program တုိင္းက ခုနက ေပါင္းမယ္ ႏွုတ္မယ္ conditional jump ခုန္မယ္ပဲလုပ္တာမဟုတ္ဘူး။ ဘာလုိေသးလဲဆုိေတာ့ IO လိုတယ္။ ဥပမာ file ဖတ္မယ္။ File ကို သြားရိုက္မယ္။ ဒါေတြလုိတယ္။အဲ့ေတာ့ ခုနက CPU task ကေန IO ကိုသြားဖတ္ရတယ္။ Response time ဆုိတာ ကိုလုိခ်င္တဲ့ ဥပမာ HTTP request တခုေပါ့ သူ.ကိုစတဲ့အခ်ိန္ကေန ၿပီး client ဘက္ကို response ၿပန္လာတဲ့အခ်ိန္ကိုတုိင္းတာ။

ခုနက Node.js သည္ response time ၿမန္တယ္ဆိုတာကုိရွင္းရရင္ non-blocking IO ေၾကာင့္လို.ဆုိရမယ္။ ဒါဆုိ Non-blocking IO ကိုရွင္းဖုိ. blocking IO ကိုရွင္းရမယ္။ Blocking IO ဆုိတာ file တခုဖတ္မယ္။ ဥပမာ

    file.read  
    otherTask();  

ဆုိပါစုိ. blocking IO မွာ file.read ဆုိတာၾကီး မၿပီးေသးသေရြ. otherTask ကိုဆင္းမလာဘူး။ file ကို ကုန္ေအာင္ဖတ္မယ္ ဖုိင္ဖတ္တဲ့အလုပ္ ၿပီးမွပဲ ေနာက္တေၾကာင္းကိုဆင္းမယ္။ ဒါကို blocking IO လို.ေခၚတယ္။ ၿမင္သာေအာင္ၿပရရင္ city mart ေတြမွာ ပိုက္ဆံရွင္းရင္ ေရွ.ကလူက မၿပီးေသးရင္ ေနာက္လူက ေရွ.လူၿပီးတာကိုေစာင့္ေနရတယ္။ ေရွ.က လူက item မ်ားေနတယ္ဆုိရင္ အမွန္က ေနာက္လူက ၀ယ္ထားတာနည္းနည္းေလးဆုိ ေနာက္လူကိုရွင္းေပလုိက္ရင္ပိုၿမန္မွာေပါ့။

Non-Blocking က်ေတာ့ ဒီလိုမဟုတ္ဘူး Lotteria မွာ သြားၿပီး ေကာင္တာမွာ မွာသလုိေပါ့။ ကိုယ္မွာထားတာ အကုန္လံုးၿပီးေအာင္ တခါတည္းေစာင့္စရာမလုိဘူး အဲ့လိုေစာင္ေ့နရင္ ကိုမၿပီးေသးသေရြ. ေနာက္လူကို process (order မွာတာ) လုပ္ေပးလို.မရဘူး။ waiting လုပ္ေနရမယ္။ အဲ့ေတာ့ ခုနက လူကို ေအာ္ဒါ မွာတာေလး ေမးလုိက္တယ္ ၿပီးရင္ device ေလးေပးလိုက္တယ္။ ကိုယ္ေအာ္ဒါမွာထားတာေလး ရရင္ ခုနက device ေလးကေန အခ်က္ၿပတယ္။သြားယူ ။ အဲ့လိုလုပ္ေတာ့ ေနာက္ကလူလဲ သိပ္မေစာင့္ရဘူး။ ဒါကို non-blocking IO လုိ.ေၿပာတယ္။ Device ေလးေပးလိုက္တယ္ ၿပီးရင္ အခ်က္ေပးတယ္ ဒါမ်ိုးကိုက်ေတာ့ non blocking IO မွာ callback လို.သံုးတယ္။

အဲ့ေတာ့ blocking IO မွာ request တခု ဥပမာ file ဖတ္မယ္ဆုိပါစုိ. file ကုိၿပီးေအာင္ဖတ္မယ္ ၿပီးမွ response ၿပန္မယ္။ ဆုိပါစုိ. file ဖတ္တာက 500 ms ၾကာမယ္ဆုိရင္ သူ. response time သည္ 500 ms ၿဖစ္မယ္။ ေစာင့္ေနရတာကိုး။ ဒါေပသိ Node.js လို non-blocking IO ေတြမွာလို ေစာင့္စရာမလုိဘူး response ကေတာ့ ခ်က္ခ်င္းၿပန္မယ္။ ေနာက္မွ callback နဲ. data ေပးမယ္ဆုိရင္ တၿခား CPU task ေတြ IO task ေတြ အလွည့္ေပးလို.ရမယ္။ အဲ့ေတာ့ response လုပ္တာ ပိုၿမန္မယ္ေပါ့။

Operating System ရဲ. thread ေတြ process ေတြ IO ဖတ္လို. thread block ၿဖစ္တာေတြ waiting ၿဖစ္တာေတြကို နားလည္ရင္ ဒီသေဘာတရားကိုပိုရွင္းလိမ့္မယ္။
