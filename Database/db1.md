## Gentle Introduction to how DBMS work internally

DBMS လို.ဆုိလိုက္လုိ.ရိွရင္ စာအုပ္ေတာ္ေတာ္မ်ားမ်ားက database design အေၾကာင္းကိုပဲရွင္းတာမ်ားတယ္။ ေစ်းကြက္မွာလဲ အဲ့လိုစာအုပ္ေတြခ်ည္းပဲ။ DBMS ကိုအထဲမွာဘယ္လုိတည္ေဆာက္ထားတယ္ ဘာေတြပါတယ္ဆုိတာရွင္းထားတဲ့ စာအုပ္က literature မွာေတာင္ ၂အုပ္လားရယ္ပဲရိွတယ္။ Compiler အေၾကာင္းေတြ OS အလုပ္လုပ္ပံုေတြ ေရးထားတဲ့စာအုပ္ကေတာ့ အေတာ္မ်ားတယ္။ ဒါေၾကာင့္ Java company Sun ကုိ Database company Oracle က၀ယ္သြားလို.ရတာလားလို.ေတာင္ စဥ္းစားမိတယ္ ![](https://static.xx.fbcdn.net/images/emoji.php/v9/eb4/1/16/FACE_WITH_COLON_THREE.png) ။ Business Application တခုလုပ္ၿပီဆုိရင္ အနည္းဆံုး data ကသိမ္းရေတာ့မယ္။ အဲ့ေတာ့ DBMS က မပါမၿဖစ္ ပါလာတယ္။ DBMS ေတြ မေပၚခင္က ဘယ္လုိသိမ္းလဲဆုိရင္ file sytem မွာပဲသိမ္းတယ္။ အဲေတာ့ access, retrieval က ခက္တယ္။ ေနာက္ပိုင္း IBM ကေန Codd ရဲ. Relational Algebra သီအုိရီ ထြက္လာေတာ့ DBMS ေတြေပၚလာတယ္။ Relational Algebra ဆိုတာသိခ်င္ရင္ေတာ့ စာလုိက္ဖတ္။

သာမာန္အားၿဖင့္ Application မွာ DBMS ကုိဘယ္လိုသံုးလဲဆုိရင္ API ေတြသံုးၿပီးေတာ့ access လုပ္တယ္။ API ကေန return ၿပန္တဲ့ data ကိုသံုးမယ္။ API ကေန database ကုိခ်ိတ္ၿပီးေတာ့ CRUD ေတြလုပ္ၾကတယ္ေပါ့။ ၿပႆနာက အဲ့တာေတြရဲ.ေနာက္မွာ တဆင့္ၿခင္းဘယ္လုိလုပ္သြားလဲဆုိတာပဲ။ သိေတာ့ဘာထူးမွာလဲဆုိတဲ့ ေၿမယိုးေတြေတာ့ ဖတ္ဖုိ.မလိုဘူး။ အဲ့ဒါေတြသိထားရင္ DBMS ကို လႊတ္လိုက္တဲ့ SQL တေၾကာင္းအတြက္ DBMS သည္ ဘယ္လုိအလုပ္လုပ္သြားရသလဲဆုိတာသိလာမယ္။ အက်ိဳးဆက္အေနနဲ. အနည္းဆံုး SQL ကိုဘယ္လုိ Optimize ၿဖစ္ေအာင္ေရးရမလဲ ဆုိတာသိလာမယ္။ ေနာက္ DBMS ကိုယ္စား စဥ္းစားတတ္လာမယ္။ (တကယ္ေတာ့ အဲ့ေလာက္ထိေတာ့မလြယ္ပါဘူး ဘာလုိ.လဲဆုိေတာ့ DBMS တခုနဲ.တခု query optimizer ေတြ အလုပ္လုပ္ပံုမတူၾကသလို ထုတ္လဲမေၿပာၾကေတာ့ သာမာန္အားၿဖင့္ သေဘာတရားေလာက္ကိုပဲသိႏုိင္မယ္)။ ေနာက္တခုက DBMS ေတြမွာ query execution plan ကုိုထုတ္ၾကည့္ႏုိင္တဲ့ tool ေတြရိွတယ္။ Query execution plan ဆုိတာ ရွင္းေအာင္ေၿပာရရင္ ကိုေရးလုိက္တဲ့ SQL ကုိဘယ္လုိအဆင့္ေတြ သံုးၿပီး အဆင့္ဆင့္လုပ္သြားမလဲ ။ေနာက္ တဆင့္ခ်င္းဆီမွာ ဘယ္ေလာက္ cost က်မလဲ (ဘယ္ေလာက္ အခ်ိန္ၾကာမလဲ memory ဘယ္ေလာက္ကုန္မလဲ) ဒါေတြကုိၾကည့္လို.ရတယ္။ အဲ့ေတာ့ performance အရ tuning လုပ္ခ်င္ရင္ ဒါေတြက အေရးပါလာၿပီ။ တကယ္က အဲ့လို အလုပ္ေတြက်ေတာ့ ဆုိင္ရာ DBA ကလုပ္ရတယ္။ ဒါေပသိ Organization တုိင္းမွာ DBA ရိွခ်င္မွ ရိွမယ္။ Programmer တေယာက္အတြက္သိထားရင္လဲ အသံုး၀င္တယ္။ MySQL workbench မွာဆုိ visually ပါၿပႏုိင္တယ္ query execution plan ကို။ Explain ကုိသံုးရင္လဲရတယ္။ စိတ္၀င္စားရင္ ဒီမွာသြားၾကည့္

https://dev.mysql.com/…/work…/en/wb-performance-explain.html

ဥပမာ Java program တခုကေန MySQL ကုိ သံုးၿပီဆုိရင္ JDBC API  
ေတြကေန လွမ္းသံုးရတယ္။ MysQL သည္ C/C++ နဲ.ေရးထားတာ။ အဲ့တာကိုဘယ္လုိလုပ္ JDBC Java ကေန လွမ္းေခၚလို.ရလဲဆုိေတာ့ JDBC driver ေတြေၾကာင့္။ JDBC Driver ေတြက ဘာလုပ္လဲဆိုေတာ့ MySQL database server ကို TCP protocol ကေန လွမ္းဆက္သြယ္တယ္။ ၿပီးေတာ့မွ Socket က ရလာတဲ့ data ေတြကုိ API ကုိၿပန္ေပးတယ္။ ဒါေၾကာင့္ TCP/IP protocol ကုိသံုးလို.သာ DMBS ေတြသည္ different langauge ကေန access လုပ္လုိ.ရတာ။ MySQL သည္ port 3306 ကိုသံုးတယ္။ ဘာေၾကာင့္ TCP ကိုသံုးတုံုးေပါ့။ ရွင္းတယ္။ UDP က data ေပ်ာက္ႏုိင္တယ္။ database လုိ stream data ေတြ ပို.မယ္ဆုိရင္ TCP ကုိသံုးတာပဲအဆင္ေၿပတယ္။ဒါေၾကာင့္ database connection တခုခ်ိတ္တုိင္းသည္ ေလးတယ္ performance ကုိထိတယ္ ဆုိတာ TCP connection ခ်ိတ္ရတယ္။ ေနာက္ ဟုိဘက္က MySQL server မွာလဲ database connection ကုိထိန္းဖုိ. process managment ေတြလုပ္ရတယ္(Process manangement ကိုသိခ်င္ရင္ေတာ့ Operating System စာအုပ္ေတြရွာဖတ္ေပါ့) ဒါေၾကာင့္ developer ေတြသည္ connection polling လုိေကာင္မ်ိဳးကိုသံုးတယ္။  
အေပၚက ပံုက technical report (paper လို.မဆိုခ်င္တာက စာမ်က္ႏွာ ၁၅၀ ေလာက္ရိွေနလို.) ကေန ယူထားတာ။

Connection ခ်ိတ္ၿပီးရင္ SQL command ေတြကို program ကေနပို.လို.ရၿပီ။ ခုနက Connection ခ်ိတ္တာရယ္ DBMS ကရလာတဲ့ result ရယ္ကိုထုတ္ေပးတာကို အေပၚပံုထဲက communication mananger ကလုပ္ေပးရတယ္။ SQL ေလး client ဘက္ကေနရၿပီဆုိရင္ DBMS ကအထဲမွာ အဲ့ဒီ SQL ကုိ process လုပ္ဖုိ. thread ကေလး တခု ဖန္တီးလိုက္ရတယ္။ ဘာလို. Thread သံုးလဲဆုိရင္ေတာ့ ဒီေနရာမွာ database server တခုသည္ concurrent connection ေတြကို create လုပ္ႏုိင္တယ္ ဒါေၾကာင့္ thread တခုခ်င္းဆီနဲ.ခြဲလုပ္တာ process ေတြ create လုပ္တာထက္စာရင္ပုိသက္သာတယ္ ဒါေၾကာင့္အဲ့လုိလုပ္တာ။ အဲ့လို thead ေတြ process ေတြ အတြက္အလုပ္လုပ္ေပးတာကေတာ့ Process Manager ဆုိတဲ့ module ကေန လုပ္ေပးရတာ။ ခုနက SQL command ေတြကို မ run ခင္မွာ ဘာလုပ္ရေသးလဲဆုိေတာ့ ဒီ client က လႊတ္လုိက္တဲ့ command ေတြသည္ client ရဲ. user permission အရ လုပ္ခြင့္ရိွသလားဆုိတာကို စစ္ရတယ္ အဲ့ဒီအလုပ္ကုိက်ေတာ့ Admission Control ဆုိတဲ့ module ကလုပ္တယ္။

ခုနက Admission ကလဲ အုိေကၿပီ SQL command သည္ user ကုိေပးသံုးထားတဲ့ ေဘာင္ထဲကေနရိွတယ္ ဒါဆုိရင္ SQL command ကုိစ run လို.ရၿပီေပါ့။ ဒါဆုိရင္ SQL ကို run ဖုိ.အတြက္ Relational Query Processor ဆီကုိပုိ.ရတယ္။ Relational Query Processor ရဲ.အလုပ္က SQL ကုိ compile လုပ္တယ္။ Compile လုပ္တယ္ဆုိတာက SQL statement ကုိ programming langauge ေတြကို parse လုပ္သလို parse လုပ္တယ္။ ၿပီးေတာ့ internal form ထုတ္တယ္။ Internal form ဆုိတာ DBMS ကေန အထဲမွာသံုးထားတဲ့ basic operation ေတြ JOIN,SELECT, Projection အစရိွတဲ့ operator ေတြနဲ.ေရးထားတဲ့ intermediate code မ်ိဳးေပါ့။ ခုနက SQL ၾကီးကို parse လုပ္ၿပီးရင္ internal query plan အေနနဲ.ထုတ္တယ္။ ဥပမာ

    SELECT * FROM Student WHERE id=3;

အတြက္ EXPLAIN SELECT * FROM Student WHERE id=3; လုိ.run လိုက္ရင္ ဒါမ်ိဳးေတြ.မယ္  

    select_type SIMPLe,table course, type const, possible_keys=PRIMARY,key=PRIMARY,key_len=4,ref=const,row=1

အေပၚက query plan သည္ DBMS အထဲမွာသံုးသြားတဲ့ ဟာ ဟုတ္ခ်င္မွဟုတ္မယ္ ဒါေပသိ SQL statement တေၾကာင္းကို basic relational operator (JOIN,SELECT,PROJECTION)အစရိွတာေတြအနဲ. ၿပန္ေၿပာင္းလိုက္တာ မ်ိဳးပဲၿဖစ္တယ္။ ဘာလို.ၿပန္ေၿပာင္းလဲဆုိေတာ့ programming language ေတြလိုပဲ statement ၾကီးတခုလံုးကုိ အထဲမွာ run ဖုိ. ဆုိင္ရာ ဆုိင္ရာ bytecode ေတြ machine instruction ေတြ run ဖုိ.အတြက္ပဲ။ SQL ရဲ. သာမာန္ programming language ေတြထက္ အားသာတာသည္ သူသည္ declarative language ၿဖစ္တယ္။ Declarative ဆုိတာ ဘာလုိခ်င္တယ္ပဲေၿပာရတယ္။ ဥပမာ SQL မွာ ORDER BY ပဲေၿပာရတယ္။ ဘယ္လို Order လုပ္မယ္ စီမယ္ဆုိတာ imperative langauge ေတြလိုေၿပာစရာမလိုဘူး။ဆုိရင္ရာ column အလိုက္ index ရိွမွူ.အေပၚလိုက္ၿပီး database အထဲမွာ ဘယ္လိုလုပ္ရမလဲဆုိတာ သူ.ဘာသာ ဆံုးၿဖတ္သြားတယ္။ ဒါေၾကာင့္ declarative လို.ေခၚတယ္။ Relational query processor ထဲမွာ ၃ ပိုင္းပါေသးတယ္။

**Query Parsing and Authorization**

သူက query ကို parse လုပ္တယ္။ parse လုပ္တယ္ဆုိတဲ့ေနရာမွာ query သည္ grammar အရ မွန္မမွန္စစ္တယ္။အဲ့ဒါတင္မကဘူး သူသည္ SQL မွာပါတဲ့ table name ေတြ column ေတြသည္ တကယ္ရိွရဲ.လား အသံုးမွန္ရဲ.လားဆုိတာမ်ိဳးပါစစ္တယ္။ ဒါမ်ိဳးကိုဘယ္လုိစစ္လဲဆုိေတာ့ DBMS ေတြမွာ metatable ေတြရိွတယ္ အဲ့ေကာင္ေတြနဲ.တုိက္ၿပီးေတာ့စစ္ရတယ္။ Catalog Manaer သည္ metatable ေတြကို ထိန္းသိမ္းတဲ့အလုပ္ကိုလုပ္ရတယ္။ Authorization ကေတာ့ ဒီ query မွာပါတဲ့ operation ေတြကို user ကုိခြင့္ေပးထားရဲ.လားဆုိတာမ်ိဳး access priviledge ကုိစစ္တာမ်ိုးစစ္ရတယ္။

**Query Rewrite**

User က ေရးလုိက္တဲ့ SQL Query ကုိ ပုိၿပီးၿမန္ေအာင္ rewrite လုပ္တဲ့သေဘာ တခါတေလ process လုပ္ရလြယ္ေအာင္လုပ္တာလဲ ပါမွာေပါ့။ ဥပမာ SELECT * FROM customer WHERE id= 2+3 ဒါဆုိ 2+3 ကုိ 5 နဲ.အစားထုိးလုိ.ရတယ္။ Query rewrite လုပ္ရင္ SELECT * FROM customer WHERE id = 5 ဆုိၿပီး ၿဖစ္သြားမယ္။ တခုသတိထားရမွာက query rewrite သည္ မူရင္း SQL မွာလုပ္ေနတာမဟုတ္ပဲ internal form မွာလုပ္ေနတယ္ဆုိတာပဲ။

**Query Optimizer**

ဒီအပိုင္းကေတာ့ DBMS တခုမွာ အေရးအၾကီးဆံုးအပိုင္းပဲ။ သူကဘာလုပ္လဲဆုိေတာ့ query plan ကုိ ပိုၿပီးေတာ့ performance ၿမင့္ေအာင္ ၿပန္ၿပင္ေရးတယ္။ ဥပမာ Table ၂ ခုကို JOIN တယ္ဆုိပါစုိ. ေနာက္ၿပီး မွ ဒုတိယ table ထဲက filed တခုကို ပဲ WHERE နဲ.စစ္ထုတ္တယ္ဆုိပါစုိ. ။ဒါဆုိ Programmer က JOIN ကို အရင္ေရးေပမဲ့ Query optimizer သည္ WHERE clause ကိုအရင္လုပ္မယ္။ ဘာလုိ.လဲဆိုေတာ့ WHERE ကိုအရင္ လုပ္လုိက္ရင္ ရလာမဲ့ row အေရအတြက္သည္ ပိုနည္းသြားမယ္ ။အဲ့ေတာ့မွ ေနာက္ table တခုနဲ. ထပ္ JOIN ရင္ result သည္ memory ေပၚမွာ တင္ရတာ ပိုသက္သာမယ္ နည္းမယ္ ပိုလဲၿမန္မယ္ေပါ့။ JOIN သည္ Caretsian product (ဒါေတြမသိရင္ CJ Date စာအုပ္ေၿပးလွန္ၾကေပါ့) ၿဖစ္တဲ့အတြက္ WHERE ၿပီးမွ JOIN တာသည္ ပိုၿမန္တယ္။ အဲ့လို Optimization ေပါင္းမ်ားစြာကို Query optimizer သည္လုပ္ရတယ္။ တၿခား အခ်က္အလက္ေတြ ဥပမာ index က ဘယ္ key နဲ.ထားတာလဲ physically အရ ဘယ္ block ၿပီးရင္ ဘယ္ေကာင္ကို ေခၚတင္ရင္ disk access သက္သာမလဲ အစရိွတာေတြပါ ထဲ့စဥ္းစားတယ္။ ၿခံဳေၿပာရရင္ User ေရးလုိက္တဲ့ SQL ကုိ heuristic algorithm ေတြသံုးၿပီး အဓိပၸာယ္မပ်က္ပဲ ပိုၿမန္ေအာင္လုပ္တယ္လုိ.ပဲဆုိရမယ္။

**Plan Executor**

ဒီအဆင့္ကေတာ့ခုနက logical query plan ကုိ execute လုပ္တာပဲ။ဆုိခ်င္တာက database ရဲ. table ေတြသည္ hard disk မွာသိမ္းထားတာ အဲ့ေတာ့ အဲ့ေကာင္ေတြကုိ JOIN လုပ္ဖုိ. select လုပ္ဖုိ. sort လုပ္ဖုိ. operation ေလးေတြတခုခ်င္းဆီလိုက္လုပ္တာလို.ေၿပာရမယ္။ Physical storage မွာ ၿမန္ၿမန္ဆန္ဆန္နဲ. ရွာႏုိင္ဖုိ. retrieve လုပ္ႏုိင္ဖုိ. ဘာကိုသံုးရသလဲဆုိရင္ မ်ားေသာအားၿဖင့္ B+ tree ဆုိတာကိုသံုးရတယ္။ B+ tree ဆုိတာ binary tree လိုသေဘာပဲ ဒါေပသိ သူ.ရဲ. internal node ေတြသည္ ထပ္ဆင့္ထပ္ဆင့္ key ေတြကိုသိမ္းသိမ္းသြားတဲ့အတြက္ ရွာရၿပဳရတာ အင္မတန္ၿမန္တယ္။ ၿမင္သာေအာင္ေၿပာရရင္ phone contact list ေတြမွာ A -Z စီထားသလိုပဲ ဘယ္ record, ဘယ္ primary key ဆုိရင္ ဘယ္နားေလာက္ရိွမယ္ဆုိတာကို ရွာရလြယ္တယ္။ Plan executor ရဲ.အလုပ္သည္ logical query plan ကုိ step by step execute လုပ္တာပဲ။ ခုနက record ေတြ table row ေတြကို ေခၚတင္ဖုိ. က်ေတာ့ဘယ္သူ.ကို ခုိင္းရလဲဆုိေတာ့ Transcational storage manager ကုိခုိင္းရေရာ။

**Transcational storage manager**

သူက CRUD operation ေတြကုိလုပ္ရတယ္။ အဲ့လိုလုပ္တဲ့အခါမွာ RDBMS သည္ ACID property ကို မေဖာက္ဖ်က္ရေအာင္ လုိက္နာရေအာင္ transcation manangement အတြက္ပါလုပ္ရတယ္။ တေယာက္က row တခုကို update လုပ္ေနခ်ိန္မွာ ေနာက္တေယာက္က ယူသံုးတာမ်ိဳးမၿဖစ္ေအာင္ lock ခ်ရတယ္။ အိမ္သာမွာ တေယာက္က သံုးေနရင္ေနာက္တေယာက္ သံုးမရေအာင္ ခ်က္ ခ်သလိုေပါ့။ အဲ့ဒါမ်ိဳးကို lock manager ကလုပ္ရတယ္။ ေနာက္ဘယ္လုိ အဆင့္ေတြ run သြားသလဲဆုိတာကို မွတ္ဖုိ.လုိတယ္။ ဒါမွ roll back, commit ,logging အတြက္အဆင္ေၿပမွာကိုး ။အဲ့ဒါေတြဖုိ. lock manager ကုိသံုးရတယ္။ ေနာက္တခုက database တခုသည္ Gibabyte အမ်ားၾကီးရိွႏုိုင္တယ္။ table တခုတည္းနဲ.တင္ ေနရာအမ်ားၾကီးယူႏဳိင္တယ္။အဲ့ေတာ့ အဲ့ခုနက hard disk ေပၚက row ေတြ record ေတြကို memory ေပၚအားလံုး တင္ထားဖုိ.ဆုိတာမၿဖစ္ႏုိင္ဘူး။အဲ့ေတာ့ ဆန္.သေလာက္ေလးပဲ ထားရတယ္။ ဒါကို က်ေတာ့ Buffer manager ကလုပ္ရတာေပါ့။ Memory management နဲ.ပတ္သတ္တဲ့ caching လုိေကာင္မ်ိဳးကိုက်ေတာ့ memory manager ကလုပ္ေပးရတယ္။ ေနာက္ DDL and other processing Utilities ဆုိတာမ်ိဳးက်ေတာ့ ဥပမာ max တို. min တုိ. တၿခား SQL မွာပါတဲ့ function ေတြရဲ. implementation အပိုင္းကိုလုပ္ရတယ္။  
Administration Monitoring က်ေတာ့ DBMS နဲ.ဆုိင္တဲ့ user role create လုပ္တာတုိ. access priviledge ထိန္းတာတုိ. monitoring လုပ္တာတုိ.ကိုတာ၀န္ယူရတယ္။ Modern database ေတြမွာ replicatation ပါလာတယ္ အဲ့ေကာင္ေတြက်ေတာ့ Replication and loading service ကလုပ္တယ္။ Batch execution က်ေတာ့ Batch utilities ကလုပ္ရတယ္။ Share component ေတြ module တခုနဲ.တခု communication က်ေတာ့ share component and utilities ကလုပ္ရတယ္။  
မွတ္ခ်က္ (နားမလည္ရင္ ဖတ္တဲ့သူညံ့လုိ. နားလည္ရင္ ေရးတဲ့သူေတာ္လို. ![](https://static.xx.fbcdn.net/images/emoji.php/v9/f9f/1/16/1f61b.png))

က်မ္းကိုး  
http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf
